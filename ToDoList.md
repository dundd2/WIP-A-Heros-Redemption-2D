# A Hero's Redemption 2D TO DO LIST Before V1.0

1.設定戰鬥模式的時候敵人的最大大小,以及確保他們圖片的位置處於遊戲顯示範圍,以內以及固定他們在遊戲內的位置,但輪到敵人,敵人選擇攻擊的時候,敵人的圖片會向左移動一下然後再回到原位,象徵著敵人向玩家攻擊,並請確保當玩家攻擊他們的時候顯示在敵人上的特效正確覆蓋在敵人的圖片上面

2.新增讓遊戲裏面的按鈕都可以用滑鼠選擇而不只是鍵盤

3.

4.幫我看看為什麼故事模式裏面故事的對話並不能夠正確出現在遊戲裏面,so far 只有看到說話角色的圖片以及他們的名稱,對話內容的文字顏色應該要是blue色的,

5.請你根據現時的代碼重新修改並且增加音效播放的觸發點,例如要是當我重新開始level,戰鬥音樂卻不會重新開始,以及多我重新回到主頁之後主頁的音樂不會播放

6.當選擇中文的時候進入故事頁面之後只有中文的標題,但內文是英文來的

7.確保在故事模式的時候敵人的圖片是在對話框的內容裏面,而且把他設定一個最大的大小限制所以敵人的圖片不會超出對話框範圍,就像在主角頭像圖片在故事內容一樣

8.在主頁新增一個選項進入類似於故事頁面一樣的頁面,裏面會有包括這個項目的介紹,以及製作人員的名稱.,鳴謝列表.而且會有一張作者的圖片為處於文章的最上方,而且將故事頁面一樣,在左上角會有按鈕讓用家回到主頁面

9.每一關的在故事模式裏面新增滑鼠按鈕進入下一個對話內容,在最後對話內容完成之後點擊會進入戰鬥模式

10.修改戰鬥模式,輪到玩家回合的時候讓玩家選擇的項目的那個列表(補血攻擊防禦特殊技能),可以使用鍵盤選擇,要是當玩家使用戰咀向上的時候就會出現錯誤,但向下選擇沒有問題

11.發揮你的創意幫我在 option頁面中增加更多可以供玩家選擇的內容選項,又或者更多的cheat option,讓玩家可以自由地設定字體的大小

12.建立合理的防禦性編程,預防錯誤發生:

2. 資源加載 (resources 表格)

問題: 資源加載部分使用了 pcall 來嘗試加載背景圖片，這是一個很好的防禦性措施，可以避免因為單個圖片加載失敗而導致整個遊戲崩潰。但是，對於其他重要資源 (例如字體、聲音效果、其他圖片)，如果加載失敗，目前的代碼似乎沒有明確的錯誤處理。

防禦性改進:

統一的資源加載錯誤處理: 為所有資源加載 (圖片、聲音、字體等) 實現統一的錯誤處理機制。可以使用一個輔助函數來封裝 love.graphics.newImage, love.audio.newSource, love.graphics.newFont 等函數，並在加載失敗時記錄錯誤信息並提供預設資源或終止遊戲 (如果資源是必須的)。

檢查必要的資源是否加載成功: 在 love.load 函數的末尾，可以加入檢查，確認所有必要的資源 (例如 UI 字體、基礎圖片等) 都已成功加載。如果關鍵資源缺失，可以顯示錯誤信息並終止遊戲，因為遊戲可能無法正常運行。

預設資源: 為關鍵資源提供預設的 fallback 資源。例如，如果某個敵人的圖片加載失敗，可以使用一個通用的佔位符圖片，而不是直接報錯或顯示空白。

3. 遊戲狀態和邏輯 (gameState, battleState, menuState 等)

問題: 遊戲狀態依賴於字符串標識符 ("menu", "battle", "victory" 等)。如果字符串拼寫錯誤，或者在狀態切換時出現邏輯錯誤，可能會導致狀態混亂或者未預期的行為。

防禦性改進:

使用枚舉或常量來定義遊戲狀態: 使用 Lua 的表格來模擬枚舉，將遊戲狀態定義為常量，例如 GAME_STATE = { MENU = "menu", BATTLE = "battle", VICTORY = "victory" }。這樣在代碼中使用狀態時，可以使用 gameState = GAME_STATE.MENU，這樣可以避免字符串拼寫錯誤，並提高代碼的可讀性。

狀態轉換驗證: 在狀態轉換的函數中 (例如 handleMenuInput, handleBattleInput 等)，可以加入驗證邏輯，確保狀態轉換是有效的。例如，從 "battle" 狀態只能轉換到 "victory", "defeat" 或 "pause" 狀態，而不是直接跳到 "menu" (除非通過暫停菜單)。

斷言 (Assertions) 用於關鍵邏輯: 在關鍵的遊戲邏輯部分，例如戰鬥傷害計算、狀態更新等，可以使用 assert 來驗證假設條件是否成立。例如，在傷害計算後，可以使用 assert(damage >= 0, "Damage should not be negative") 來確保傷害值是非負的。在開發階段，斷言可以幫助快速發現邏輯錯誤。

4. 輸入處理 (love.keypressed, love.mousepressed)

問題: 輸入處理函數 (例如 love.keypressed) 中，使用了大量的 if-elseif 結構來判斷按鍵和執行不同的操作。如果狀態和邏輯變得更複雜，這些函數可能會變得難以維護和理解。

防禦性改進:

輸入映射配置: 考慮使用一個配置表格來定義按鍵和操作之間的映射關係。例如，可以定義一個表格，將 "return" 鍵映射到 "select_option" 操作，將 "escape" 鍵映射到 "back" 操作。然後，輸入處理函數只需要根據當前遊戲狀態和按下的按鍵，從映射表中查找對應的操作並執行。這樣可以提高輸入處理的靈活性和可配置性。

事件驅動的輸入處理: 更進階的做法是使用事件驅動的輸入處理機制。當按鍵按下時，觸發一個事件 (例如 "menu_select_pressed", "battle_attack_selected")，然後由事件處理器來處理這些事件。這樣可以將輸入處理邏輯和遊戲邏輯解耦，提高代碼的模塊化程度。

5. 數值和計算 (傷害計算, 冷卻時間)

問題: 傷害計算函數 calculateDamage 中，使用了 math.random(-0.1, 0.1) 來增加隨機性。雖然這增加了遊戲的變化性，但如果隨機數的範圍或計算邏輯有誤，可能會導致傷害值超出預期範圍，或者出現其他數值錯誤。

防禦性改進:

數值範圍驗證: 在傷害計算、治療量計算等數值計算的關鍵步驟中，可以加入數值範圍驗證，確保計算結果在合理的範圍內。例如，傷害值不應該是負數，生命值不應該超過最大生命值。

使用常量定義關鍵數值: 將遊戲中的關鍵數值，例如基礎攻擊力、防禦係數、暴擊率、冷卻時間等，定義為常量 (例如使用全大寫變量名 BASE_ATTACK = 10)，而不是硬編碼在代碼中。這樣可以提高代碼的可讀性和可維護性，並且方便調整遊戲平衡性。


7. 定時器系統 (timers 表格, addTimer, updateTimers)

問題: 目前的定時器系統看起來比較基礎。如果遊戲需要更複雜的定時器管理，例如取消定時器、暫停/恢復定時器等功能，可能需要擴展這個系統。

防禦性改進:

定時器 ID 管理: 為每個定時器分配一個唯一的 ID，方便後續對定時器進行管理，例如取消定時器。

定時器狀態管理: 可以為定時器添加狀態 (例如 "active", "paused", "cancelled")，以便在遊戲邏輯中可以控制定時器的行為。

定時器組管理: 如果遊戲中有大量定時器，可以考慮將定時器分組管理，例如根據功能或遊戲階段將定時器分組，方便批量操作定時器。



Turn-based RPG using Love2D Framework. Personal demo for better understand the challenges in a larger Unity 3D group project later this year
